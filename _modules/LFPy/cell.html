<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LFPy.cell &mdash; LFPy 1.1.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="LFPy 1.1.2 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-29024998-1']);
  _gaq.push(['_gat._anonymizeIp']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">LFPy 1.1.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for LFPy.cell</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Copyright (C) 2012 Computational Neuroscience Group, UMB.</span>

<span class="sd">This program is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU General Public License as published by</span>
<span class="sd">the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">This program is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU General Public License for more details.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">neuron</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">LFPy</span> <span class="kn">import</span> <span class="n">RecExtElectrode</span>
<span class="kn">from</span> <span class="nn">LFPy.run_simulation</span> <span class="kn">import</span> <span class="n">_run_simulation</span><span class="p">,</span> <span class="n">_run_simulation_with_electrode</span>
<span class="kn">from</span> <span class="nn">LFPy.run_simulation</span> <span class="kn">import</span> <span class="n">_collect_geometry_neuron</span>
<span class="kn">from</span> <span class="nn">LFPy.alias_method</span> <span class="kn">import</span> <span class="n">alias_method</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<div class="viewcode-block" id="Cell"><a class="viewcode-back" href="../../classes.html#LFPy.Cell">[docs]</a><span class="k">class</span> <span class="nc">Cell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The main cell class used in LFPy.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">    ::</span>
<span class="sd">        </span>
<span class="sd">        morphology : [str]: path/to/morphology/file</span>
<span class="sd">    </span>
<span class="sd">        v_init: [-65.]: initial potential</span>
<span class="sd">        passive: [True]/False: passive mechs are initialized if True</span>
<span class="sd">        Ra: [150.]: axial resistance</span>
<span class="sd">        rm: [30000]: membrane resistivity</span>
<span class="sd">        cm: [1.0]: membrane capacitance</span>
<span class="sd">        e_pas: [-65.]: passive mechanism reversal potential</span>
<span class="sd">        extracellular: [True]/False: switch for NEURON&#39;s extracellular mechanism</span>
<span class="sd">    </span>
<span class="sd">        timeres_NEURON: [0.1]: internal dt for NEURON simulation</span>
<span class="sd">        timeres_python: [0.1]: overall dt for python simulation</span>
<span class="sd">    </span>
<span class="sd">        tstartms: [0.]:  initialization time for simulation &lt;= 0 ms</span>
<span class="sd">        tstopms: [100.]: stop time for simulation &gt; 0 ms</span>
<span class="sd">    </span>
<span class="sd">        nsegs_method: [&#39;lambda100&#39;]/&#39;lambda_f&#39;/&#39;fixed_length&#39;: nseg rule</span>
<span class="sd">        max_nsegs_length: [None]: max segment length for method &#39;fixed_length&#39;</span>
<span class="sd">        lambda_f: [100]: AC frequency for method &#39;lambda_f&#39;</span>
<span class="sd">        d_lambda: [0.1]: parameter for d_lambda rule</span>
<span class="sd">        </span>
<span class="sd">        delete_sections: [True]: delete pre-existing section-references</span>
<span class="sd">        </span>
<span class="sd">        custom_code: [None]: list of model-specific code files ([.py/.hoc])</span>
<span class="sd">        custom_fun: [None]: list of model-specific functions with args</span>
<span class="sd">        custom_fun_args: [None]: list of args passed to custom_fun functions</span>
<span class="sd">        pt3d: True/[False]: use pt3d-info of the cell geometries switch</span>
<span class="sd">        celsius: [None]: Temperature in celsius. If nothing is specified here or in custom code it is 6.3 C</span>
<span class="sd">        verbose: True/[False]: verbose output switch</span>
<span class="sd">    </span>
<span class="sd">    Usage of cell class:</span>
<span class="sd">    ::</span>
<span class="sd">        </span>
<span class="sd">        import LFPy</span>
<span class="sd">        cellParameters = {                          </span>
<span class="sd">            &#39;morphology&#39; : &#39;path/to/morphology&#39;,</span>
<span class="sd">            &#39;rm&#39; : 30000,</span>
<span class="sd">            &#39;cm&#39; : 1.0,</span>
<span class="sd">            &#39;Ra&#39; : 150,</span>
<span class="sd">            &#39;timeres_NEURON&#39; : 0.1,</span>
<span class="sd">            &#39;timeres_python&#39; : 0.1,</span>
<span class="sd">            &#39;tstartms&#39; : -50,</span>
<span class="sd">            &#39;tstopms&#39; : 50,</span>
<span class="sd">        }</span>
<span class="sd">        cell = LFPy.Cell(**cellParameters)</span>
<span class="sd">        cell.simulate()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">morphology</span><span class="p">,</span>
                    <span class="n">v_init</span><span class="o">=-</span><span class="mf">65.</span><span class="p">,</span>
                    <span class="n">passive</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="n">Ra</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
                    <span class="n">rm</span><span class="o">=</span><span class="mi">30000</span><span class="p">,</span>
                    <span class="n">cm</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">e_pas</span><span class="o">=-</span><span class="mf">65.</span><span class="p">,</span>
                    <span class="n">extracellular</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="n">timeres_NEURON</span><span class="o">=</span><span class="mi">2</span><span class="o">**-</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">timeres_python</span><span class="o">=</span><span class="mi">2</span><span class="o">**-</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">tstartms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">tstopms</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                    <span class="n">nsegs_method</span><span class="o">=</span><span class="s1">&#39;lambda100&#39;</span><span class="p">,</span>
                    <span class="n">lambda_f</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                    <span class="n">d_lambda</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                    <span class="n">max_nsegs_length</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">delete_sections</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                    <span class="n">custom_code</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">custom_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">custom_fun_args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">pt3d</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">celsius</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialization of the Cell object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pt3d</span> <span class="o">=</span> <span class="n">pt3d</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="s1">&#39;d_lambda&#39;</span><span class="p">):</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="s1">&#39;stdlib.hoc&#39;</span><span class="p">)</span>    <span class="c1">#NEURON std. library</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="s1">&#39;import3d.hoc&#39;</span><span class="p">)</span>  <span class="c1">#import 3D morphology lib</span>

        <span class="k">if</span> <span class="n">delete_sections</span><span class="p">:</span>
            <span class="n">numsec</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">numsec</span><span class="p">,</span> <span class="n">sec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">allsec</span><span class="p">()):</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">numsec</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> existing sections deleted from memory&#39;</span> <span class="o">%</span> <span class="n">numsec</span><span class="p">))</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="s1">&#39;forall delete_section()&#39;</span><span class="p">)</span>

        <span class="c1">#print a warning if neuron have existing sections</span>
        <span class="n">numsec</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">numsec</span><span class="p">,</span> <span class="n">sec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">allsec</span><span class="p">()):</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">numsec</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">mssg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> sections detected! &quot;</span> <span class="o">%</span> <span class="n">numsec</span> <span class="o">+</span> \
                   <span class="s2">&quot;Consider setting &#39;delete_sections=True&#39;&quot;</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">mssg</span><span class="p">)</span>
                
        <span class="c1">#load morphology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span> <span class="o">=</span> <span class="n">morphology</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_geometry</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;non-existent file </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1">#will try to import top level cell and create sectionlist,</span>
                <span class="c1">#in case there were no morphology file loaded</span>
                <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">define_shape</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_sectionlists</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Could not load existent top-level cell&quot;</span><span class="p">)</span>
        
        <span class="c1">#Some parameters and lists initialised</span>
        <span class="k">if</span> <span class="n">timeres_python</span> <span class="ow">not</span> <span class="ow">in</span> <span class="mf">2.</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">timeres_NEURON</span> \
                <span class="ow">not</span> <span class="ow">in</span> <span class="mf">2.</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;timeres_python and or timeres_NEURON not a power of 2,&#39;</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;cell.tvec errors may occur.&#39;</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Initialization will continue.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">timeres_python</span> <span class="o">&lt;</span> <span class="n">timeres_NEURON</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;timeres_python = </span><span class="si">%.3e</span><span class="s1"> &lt; timeres_NEURON = </span><span class="si">%.3e</span><span class="s1">&#39;</span> \
                                        <span class="o">%</span> <span class="p">(</span><span class="n">timeres_python</span><span class="p">,</span> <span class="n">timeres_NEURON</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span> <span class="o">=</span> <span class="n">timeres_python</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeres_NEURON</span> <span class="o">=</span> <span class="n">timeres_NEURON</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">tstartms</span> <span class="o">=</span> <span class="n">tstartms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">=</span> <span class="n">tstopms</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synidx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointprocesses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointprocess_idx</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">v_init</span> <span class="o">=</span> <span class="n">v_init</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">default_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_rotation</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">passive</span><span class="p">:</span>
            <span class="c1">#Set passive properties, insert passive on all segments</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ra</span> <span class="o">=</span> <span class="n">Ra</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rm</span> <span class="o">=</span> <span class="n">rm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">cm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">e_pas</span> <span class="o">=</span> <span class="n">e_pas</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_passive</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;No passive properties added&#39;</span><span class="p">)</span>
        
        <span class="c1">#run user specified code and functions if argument given</span>
        <span class="k">if</span> <span class="n">custom_code</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">custom_fun</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_run_custom_codes</span><span class="p">(</span><span class="n">custom_code</span><span class="p">,</span> <span class="n">custom_fun</span><span class="p">,</span> <span class="n">custom_fun_args</span><span class="p">)</span>
        
        <span class="c1">#Insert extracellular mech on all segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extracellular</span> <span class="o">=</span> <span class="n">extracellular</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extracellular</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_extracellular</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;no extracellular mechanism inserted, can&#39;t access imem!&quot;</span><span class="p">)</span>
        
        <span class="c1">#set number of segments accd to rule, and calculate the number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_nsegs</span><span class="p">(</span><span class="n">nsegs_method</span><span class="p">,</span> <span class="n">lambda_f</span><span class="p">,</span> <span class="n">d_lambda</span><span class="p">,</span> <span class="n">max_nsegs_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_totnsegs</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Total number of segments: </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">)</span>
        
        <span class="c1">#extract pt3d info from NEURON, and set these with the same rotation</span>
        <span class="c1">#and position in space as in our simulations, assuming RH rule, which</span>
        <span class="c1">#NEURON do NOT use in shape plot</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt3d</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_pt3d</span><span class="p">()</span>

        <span class="c1">#Gather geometry, set position and rotation of morphology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_geometry</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;somapos&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_pos</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;no soma, using the midpoint if initial segment.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_rotation</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">default_rotation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">celsius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">celsius</span> <span class="o">!=</span> <span class="mf">6.3</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Overwriting custom temperature of </span><span class="si">%1.2f</span><span class="s2">. New temperature is </span><span class="si">%1.2f</span><span class="s2">&quot;</span>
                      <span class="o">%</span> <span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">celsius</span><span class="p">,</span> <span class="n">celsius</span><span class="p">))</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">celsius</span> <span class="o">=</span> <span class="n">celsius</span>


    <span class="k">def</span> <span class="nf">_load_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Load the morphology-file in NEURON&#39;&#39;&#39;</span> 
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">sec_counted</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="s1">&#39;sec_counted = 0&#39;</span><span class="p">)</span>
        
        <span class="c1">#import the morphology, try and determine format</span>
        <span class="n">fileEnding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;hoc&#39;</span> <span class="ow">or</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;HOC&#39;</span><span class="p">:</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="s1">&#39;objref this&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;asc&#39;</span> <span class="ow">or</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;ASC&#39;</span><span class="p">:</span>
                <span class="n">Import</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Import3d_Neurolucida3</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="n">Import</span><span class="o">.</span><span class="n">quiet</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;swc&#39;</span> <span class="ow">or</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;SWC&#39;</span><span class="p">:</span>
                <span class="n">Import</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Import3d_SWC_read</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;xml&#39;</span> <span class="ow">or</span> <span class="n">fileEnding</span> <span class="o">==</span> <span class="s1">&#39;XML&#39;</span><span class="p">:</span>
                <span class="n">Import</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Import3d_MorphML</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a recognised morphology file format!&#39;</span>
                                 <span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span>
                    <span class="s1">&#39;Should be either .hoc, .asc, .swc, .xml!&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">)</span>
            
            <span class="c1">#assuming now that morphologies file is the correct format</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Import</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="s1">&#39;neuroml&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Can not import, try and copy the &#39;</span> <span class="o">+</span> \
                    <span class="s1">&#39;nrn/share/lib/python/neuron/neuroml &#39;</span> <span class="o">+</span> \
                    <span class="s1">&#39;folder into </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">neuron</span><span class="o">.</span><span class="n">__path__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;something wrong with file, see output&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">imprt</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Import3d_GUI</span><span class="p">(</span><span class="n">Import</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;See output, try to correct the file&#39;</span><span class="p">)</span>
            <span class="n">imprt</span><span class="o">.</span><span class="n">instantiate</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
            
        <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">define_shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_sectionlists</span><span class="p">()</span>

        
    <span class="k">def</span> <span class="nf">_run_custom_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">custom_code</span><span class="p">,</span> <span class="n">custom_fun</span><span class="p">,</span> <span class="n">custom_fun_args</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Execute custom model code and functions with arguments&#39;&#39;&#39;</span>
        <span class="c1"># load custom codes</span>
        <span class="k">if</span> <span class="n">custom_code</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">custom_code</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;hoc&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">xopen</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                        <span class="n">ERRMSG</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;Could not load custom model code (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="n">code</span><span class="p">,</span> 
                            <span class="s1">&#39;while creating a Cell object.&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;One possible cause is the NEURON mechanisms have&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;not been compiled, &#39;</span><span class="p">,</span>
                            <span class="s1">&#39;try running nrnivmodl. &#39;</span><span class="p">,])</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">ERRMSG</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">code</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;py&#39;</span><span class="p">:</span>
                    <span class="k">exec</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> not a .hoc- nor .py-file&#39;</span> <span class="o">%</span> <span class="n">code</span><span class="p">)</span>
        
        <span class="c1"># run custom functions with arguments</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">custom_fun</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fun</span> <span class="ow">in</span> <span class="n">custom_fun</span><span class="p">:</span>
                <span class="n">fun</span><span class="p">(</span><span class="o">**</span><span class="n">custom_fun_args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span>  <span class="mi">1</span>
        
        <span class="c1">#recreate sectionlists in case something changed</span>
        <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">define_shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_sectionlists</span><span class="p">()</span>

    
    <span class="k">def</span> <span class="nf">_set_nsegs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsegs_method</span><span class="p">,</span> <span class="n">lambda_f</span><span class="p">,</span> <span class="n">d_lambda</span><span class="p">,</span> <span class="n">max_nsegs_length</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Set number of segments per section according to the lambda-rule,</span>
<span class="sd">        or according to maximum length of segments&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">nsegs_method</span> <span class="o">==</span> <span class="s1">&#39;lambda100&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_nsegs_lambda100</span><span class="p">(</span><span class="n">d_lambda</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nsegs_method</span> <span class="o">==</span> <span class="s1">&#39;lambda_f&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_nsegs_lambda_f</span><span class="p">(</span><span class="n">lambda_f</span><span class="p">,</span> <span class="n">d_lambda</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nsegs_method</span> <span class="o">==</span> <span class="s1">&#39;fixed_length&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_nsegs_fixed_length</span><span class="p">(</span><span class="n">max_nsegs_length</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;No nsegs_method applied (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">nsegs_method</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">_get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Check if there exists a corresponding file</span>
<span class="sd">        with rotation angles&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">morphology</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">base</span><span class="o">+</span><span class="s1">&#39;.rot&#39;</span><span class="p">):</span>
                <span class="n">rotation_file</span> <span class="o">=</span> <span class="n">base</span><span class="o">+</span><span class="s1">&#39;.rot&#39;</span>
                <span class="n">rotation_data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">rotation_file</span><span class="p">)</span>
                <span class="n">rotation</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">rotation_data</span><span class="p">:</span>
                    <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                    <span class="n">rotation</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rotation</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">rotation</span>

    <span class="k">def</span> <span class="nf">_create_sectionlists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create section lists for different kinds of sections&#39;&#39;&#39;</span>
        <span class="c1">#list with all sections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allsecnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">SectionList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">allsec</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allsecnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">=</span><span class="n">sec</span><span class="p">)</span>
        
        <span class="c1">#list of soma sections, assuming it is named on the format &quot;soma*&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsomasec</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">somalist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">SectionList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">allsec</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;soma&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">somalist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">=</span><span class="n">sec</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nsomasec</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="k">def</span> <span class="nf">_get_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seclist</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return boolean vector which indexes where segments in seclist </span>
<span class="sd">        matches segments in neuron.h.allsec(), rewritten from </span>
<span class="sd">        LFPy.hoc function get_idx()&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">allsec</span><span class="p">()</span> <span class="o">==</span> <span class="n">seclist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idxvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="c1">#get sectionnames from seclist</span>
            <span class="n">seclistnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">seclist</span><span class="p">:</span>
                <span class="n">seclistnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
            <span class="n">seclistnames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seclistnames</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S128&#39;</span><span class="p">)</span>
            <span class="n">segnames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S128&#39;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
                <span class="n">secname</span> <span class="o">=</span> <span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                    <span class="n">segnames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">secname</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">seclistnames</span><span class="p">:</span>
                <span class="n">idxvec</span><span class="p">[</span><span class="n">segnames</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">return</span> <span class="n">idxvec</span>
    
    <span class="k">def</span> <span class="nf">_set_nsegs_lambda_f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">d_lambda</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Set the number of segments for section according to the </span>
<span class="sd">        d_lambda-rule for a given input frequency</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            frequency: float, frequency at whihc AC length constant is computed</span>
<span class="sd">            d_lambda: float, </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">sec</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="p">(</span><span class="n">d_lambda</span><span class="o">*</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">lambda_f</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span>
                                                           <span class="n">sec</span><span class="o">=</span><span class="n">sec</span><span class="p">))</span> <span class="o">+</span> <span class="o">.</span><span class="mi">9</span><span class="p">)</span>
                <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">((</span><span class="s2">&quot;set nsegs using lambda-rule with frequency </span><span class="si">%i</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">frequency</span><span class="p">))</span>
   
    <span class="k">def</span> <span class="nf">_set_nsegs_lambda100</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lambda</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Set the numbers of segments using d_lambda(100)&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_nsegs_lambda_f</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">d_lambda</span><span class="o">=</span><span class="n">d_lambda</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_set_nsegs_fixed_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxlength</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Set nseg for sections so that every segment L &lt; maxlength&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">maxlength</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">def</span> <span class="nf">_calc_totnsegs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Calculate the number of segments in the allseclist&#39;&#39;&#39;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">sec</span><span class="o">.</span><span class="n">nseg</span>
        
        <span class="k">return</span> <span class="n">i</span>
    
    <span class="k">def</span> <span class="nf">_check_currents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Check that the sum of all membrane and electrode currents over all</span>
<span class="sd">        segments is sufficiently close to zero&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;this function need to be written&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_set_passive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Insert passive mechanism on all segments&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;pas&#39;</span><span class="p">)</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">Ra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ra</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">g_pas</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rm</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">e_pas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_pas</span>
    
    <span class="k">def</span> <span class="nf">_set_extracellular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Insert extracellular mechanism on all sections</span>
<span class="sd">        to access i_membrane&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="n">sec</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;extracellular&#39;</span><span class="p">)</span>
            
<div class="viewcode-block" id="Cell.set_synapse"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.set_synapse">[docs]</a>    <span class="k">def</span> <span class="nf">set_synapse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">syntype</span><span class="p">,</span>
                    <span class="n">record_current</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">record_potential</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Insert syntype (e.g. ExpSyn) synapse on segment with index idx, </span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            idx : int</span>
<span class="sd">            syntype : str</span>
<span class="sd">            record_current : bool</span>
<span class="sd">            record_potential : bool</span>
<span class="sd">            weight : float            </span>
<span class="sd">            kwargs : arguments passed on from class Synapse</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;synlist&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">synlist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;synireclist&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">synireclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;synvreclist&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">synvreclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;netstimlist&#39;</span><span class="p">):</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">netstimlist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;netconlist&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">netconlist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;sptimeslist&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sptimeslist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">cmd1</span> <span class="o">=</span> <span class="s1">&#39;syn = neuron.h.&#39;</span>
        <span class="n">cmd2</span> <span class="o">=</span> <span class="s1">&#39;(seg.x, sec=sec)&#39;</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="n">command</span> <span class="o">=</span> <span class="n">cmd1</span> <span class="o">+</span> <span class="n">syntype</span> <span class="o">+</span> <span class="n">cmd2</span>  
                    <span class="k">exec</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;syn.&#39;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">param</span><span class="p">]))</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">synlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">syn</span><span class="p">)</span>  

                    <span class="c1">#create NetStim (generator) and NetCon (connection) objects</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">netstimlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">NetStim</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">netstimlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mi">0</span>
                    
                    <span class="n">nc</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">NetCon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">netstimlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">syn</span><span class="p">)</span>
                    <span class="n">nc</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">netconlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span>

                    <span class="c1">#record currents</span>
                    <span class="k">if</span> <span class="n">record_current</span><span class="p">:</span>
                        <span class="n">synirec</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">synirec</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">syn</span><span class="o">.</span><span class="n">_ref_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">synireclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synirec</span><span class="p">)</span>

                    <span class="c1">#record potential</span>
                    <span class="k">if</span> <span class="n">record_potential</span><span class="p">:</span>
                        <span class="n">synvrec</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">synvrec</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">synvreclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synvrec</span><span class="p">)</span>

                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">synlist</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Cell.set_point_process"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.set_point_process">[docs]</a>    <span class="k">def</span> <span class="nf">set_point_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pptype</span><span class="p">,</span> <span class="n">record_current</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Insert pptype-electrode type pointprocess on segment numbered</span>
<span class="sd">        idx on cell object, with keyword arguments according to types </span>
<span class="sd">        SEClamp, VClamp, IClamp, SinIClamp, ChirpIClamp.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            idx : int</span>
<span class="sd">            pptype : str</span>
<span class="sd">            record_current : bool</span>
<span class="sd">            kwargs : arguments passed on from class StimIntElectrode</span>
<span class="sd">            </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;stimlist&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stimlist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;stimireclist&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stimireclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cmd1</span> <span class="o">=</span> <span class="s1">&#39;stim = neuron.h.&#39;</span>
        <span class="n">cmd2</span> <span class="o">=</span> <span class="s1">&#39;(seg.x, sec=sec)&#39;</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="n">command</span> <span class="o">=</span> <span class="n">cmd1</span> <span class="o">+</span> <span class="n">pptype</span> <span class="o">+</span> <span class="n">cmd2</span>  
                    <span class="k">exec</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">exec</span><span class="p">(</span><span class="s1">&#39;stim.&#39;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">param</span><span class="p">]))</span>
                        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
                            <span class="n">ERRMSG</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;Point process type &quot;{0}&quot; might not &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">pptype</span><span class="p">),</span>
                                <span class="s1">&#39;recognize attribute &quot;{0}&quot;. &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param</span><span class="p">),</span>
                                <span class="s1">&#39;Check for misspellings&#39;</span><span class="p">])</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">ERRMSG</span><span class="p">)</span>                            
                    <span class="bp">self</span><span class="o">.</span><span class="n">stimlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stim</span><span class="p">)</span>
                    
                    <span class="c1">#record current</span>
                    <span class="k">if</span> <span class="n">record_current</span><span class="p">:</span>
                        <span class="n">stimirec</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">stimirec</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">stim</span><span class="o">.</span><span class="n">_ref_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stimireclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stimirec</span><span class="p">)</span>
                
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stimlist</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span></div>
    
    <span class="k">def</span> <span class="nf">_collect_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Collects x, y, z-coordinates from NEURON&#39;&#39;&#39;</span>
        <span class="c1">#None-type some attributes if they do not exis:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xstart&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zstart</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xend</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yend</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zend</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diam</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="n">_collect_geometry_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_midpoints</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="s1">&#39;soma&#39;</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xmids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
            <span class="n">ymids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
            <span class="n">zmids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xmids</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ymids</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">zmids</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;There is no soma!&#39;</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;using first segment as root point&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">somaidx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Huh?!&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_calc_midpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Calculate midpoints of each segment&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xmid</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">xend</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ymid</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">yend</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zstart</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">zend</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>


<div class="viewcode-block" id="Cell.get_idx"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_idx">[docs]</a>    <span class="k">def</span> <span class="nf">get_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;allsec&#39;</span><span class="p">,</span> <span class="n">z_min</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span> <span class="n">z_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns neuron idx of segments from sections with names that match</span>
<span class="sd">        the pattern defined in input section on interval [z_min, z_max].</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            section: str, any entry in cell.allsecnames or just &#39;allsec&#39;.</span>
<span class="sd">            z_min: float, depth filter</span>
<span class="sd">            z_max: float depth filter</span>
<span class="sd">        </span>
<span class="sd">        Usage:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            idx = cell.get_idx(section=&#39;allsec&#39;)</span>
<span class="sd">            print idx</span>
<span class="sd">            idx = cell.get_idx(section=[&#39;soma&#39;, &#39;dend&#39;, &#39;apic&#39;])</span>
<span class="sd">            print idx</span>
<span class="sd">            </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">section</span> <span class="o">==</span> <span class="s1">&#39;allsec&#39;</span><span class="p">:</span> 
            <span class="n">seclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">allsec</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">SectionList</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">section</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">section</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">seclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">=</span><span class="n">sec</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">section</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">secname</span> <span class="ow">in</span> <span class="n">section</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">secname</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">seclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">=</span><span class="n">sec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> did not match any section name&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">section</span><span class="p">)))</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_idx</span><span class="p">(</span><span class="n">seclist</span><span class="p">)</span>
        <span class="n">sel_z_idx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">z_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">)[</span><span class="n">idx</span><span class="p">][</span><span class="n">sel_z_idx</span><span class="p">]</span></div>
                            
                
<div class="viewcode-block" id="Cell.get_closest_idx"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_closest_idx">[docs]</a>    <span class="k">def</span> <span class="nf">get_closest_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;allsec&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get the index number of a segment in specified section which </span>
<span class="sd">        midpoint is closest to the coordinates defined by the user</span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            x: float, coordinate</span>
<span class="sd">            y: float, coordinate</span>
<span class="sd">            z: float, coordinate</span>
<span class="sd">            section: str, string matching a section-name</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xmid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ymid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">mindist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">mindist</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="Cell.get_rand_idx_area_norm"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_rand_idx_area_norm">[docs]</a>    <span class="k">def</span> <span class="nf">get_rand_idx_area_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;allsec&#39;</span><span class="p">,</span> <span class="n">nidx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">z_min</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span> <span class="n">z_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return nidx segment indices in section with random probability</span>
<span class="sd">        normalized to the membrane area of segment on </span>
<span class="sd">        interval [z_min, z_max]</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            section: str, string matching a section-name</span>
<span class="sd">            nidx: int, number of random indices</span>
<span class="sd">            z_min: float, depth filter</span>
<span class="sd">            z_max: float depth filter            </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">poss_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">,</span> <span class="n">z_min</span><span class="o">=</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="o">=</span><span class="n">z_max</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nidx</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;nidx &lt; 1, returning empty array&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="n">poss_idx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;No possible segment idx match enquire! returning empty array&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">poss_idx</span><span class="p">]</span>
            <span class="n">area</span> <span class="o">/=</span> <span class="n">area</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">alias_method</span><span class="p">(</span><span class="n">poss_idx</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">nidx</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">idx</span></div>
    
<div class="viewcode-block" id="Cell.simulate"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">electrode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rec_imem</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rec_vmem</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">rec_ipas</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rec_icap</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">rec_isyn</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rec_vmemsyn</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rec_istim</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">rec_variables</span><span class="o">=</span><span class="p">[],</span> <span class="n">variable_dt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
                 <span class="n">to_memory</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">to_file</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">dotprodcoeffs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is the main function running the simulation of the NEURON model.</span>
<span class="sd">        Start NEURON simulation and record variables specified by arguments.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            electrode:  Either an LFPy.RecExtElectrode object or a list of such.</span>
<span class="sd">                        If supplied, LFPs will be calculated at every time step</span>
<span class="sd">                        and accessible as electrode.LFP. If a list of objects</span>
<span class="sd">                        is given, accessible as electrode[0].LFP etc.</span>
<span class="sd">            rec_imem:   If true, segment membrane currents will be recorded</span>
<span class="sd">                        If no electrode argument is given, it is necessary to</span>
<span class="sd">                        set rec_imem=True in order to calculate LFP later on.</span>
<span class="sd">                        Units of (nA).</span>
<span class="sd">            rec_vmem:   record segment membrane voltages (mV)</span>
<span class="sd">            rec_ipas:   record passive segment membrane currents (nA)</span>
<span class="sd">            rec_icap:   record capacitive segment membrane currents (nA)</span>
<span class="sd">            rec_isyn:   record synaptic currents of from Synapse class (nA)</span>
<span class="sd">            rec_vmemsyn:    record membrane voltage of segments with Synapse(mV)</span>
<span class="sd">            rec_istim:  record currents of StimIntraElectrode (nA)</span>
<span class="sd">            rec_variables: list of variables to record, i.e arg=[&#39;cai&#39;, ]</span>
<span class="sd">            variable_dt: boolean, using variable timestep in NEURON</span>
<span class="sd">            atol:       absolute tolerance used with NEURON variable timestep </span>
<span class="sd">            to_memory:  only valid with electrode, store lfp in -&gt; electrode.LFP </span>
<span class="sd">            to_file:    only valid with electrode, save LFPs in hdf5 file format </span>
<span class="sd">            file_name:  name of hdf5 file, &#39;.h5&#39; is appended if it doesnt exist</span>
<span class="sd">            dotprodcoeffs :  list of N x Nseg np.ndarray. These arrays will at</span>
<span class="sd">                        every timestep be multiplied by the membrane currents.</span>
<span class="sd">                        Presumably useful for memory efficient csd or lfp calcs</span>
<span class="sd">            &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_soma_volt_recorder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_tvec</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">rec_imem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_imem_recorders</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rec_vmem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_voltage_recorders</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rec_ipas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_ipas_recorders</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rec_icap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_icap_recorders</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_variable_recorders</span><span class="p">(</span><span class="n">rec_variables</span><span class="p">)</span>
        
        <span class="c1">#run fadvance until t &gt;= tstopms, and calculate LFP if asked for</span>
        <span class="k">if</span> <span class="n">electrode</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">dotprodcoeffs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">rec_imem</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s2">&quot;rec_imem = </span><span class="si">%s</span><span class="s2">, membrane currents will not be recorded!&quot;</span> \
                                  <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">rec_imem</span><span class="p">)))</span>
            <span class="n">_run_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_dt</span><span class="p">,</span> <span class="n">atol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#allow using both electrode and additional coefficients:</span>
            <span class="n">_run_simulation_with_electrode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">electrode</span><span class="p">,</span> <span class="n">variable_dt</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span>
                                               <span class="n">to_memory</span><span class="p">,</span> <span class="n">to_file</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span>
                                               <span class="n">dotprodcoeffs</span><span class="p">)</span>
        <span class="c1">#somatic trace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">somav</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">somav</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">rec_imem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_imem</span><span class="p">()</span>        
        <span class="k">if</span> <span class="n">rec_ipas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ipas</span><span class="p">()</span>        
        <span class="k">if</span> <span class="n">rec_icap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_icap</span><span class="p">()</span>        
        <span class="k">if</span> <span class="n">rec_vmem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_vmem</span><span class="p">()</span>        
        <span class="k">if</span> <span class="n">rec_isyn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_isyn</span><span class="p">()</span>        
        <span class="k">if</span> <span class="n">rec_vmemsyn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_vsyn</span><span class="p">()</span>        
        <span class="k">if</span> <span class="n">rec_istim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_istim</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rec_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collect_rec_variables</span><span class="p">(</span><span class="n">rec_variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;netstimlist&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">netstimlist</span></div>

    <span class="k">def</span> <span class="nf">_collect_tvec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set the tvec to be a monotonically increasing numpy array after sim.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \
                            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span>
        
    <span class="k">def</span> <span class="nf">_calc_imem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fetch the vectors from the memireclist and calculate self.imem</span>
<span class="sd">        containing all the membrane currents.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memireclist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imem</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imem</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1E-2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memireclist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">memireclist</span>
    
    <span class="k">def</span> <span class="nf">_calc_ipas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the passive currents</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ipas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memipasreclist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ipas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ipas</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1E-2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memipasreclist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">memipasreclist</span>
    
    <span class="k">def</span> <span class="nf">_calc_icap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the capacitive currents</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">icap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memicapreclist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">icap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">icap</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1E-2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memicapreclist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">memicapreclist</span>
    
    <span class="k">def</span> <span class="nf">_collect_vmem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the membrane currents</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vmem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memvreclist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memvreclist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">memvreclist</span>
    
    <span class="k">def</span> <span class="nf">_collect_isyn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the synaptic currents</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">syn</span><span class="o">.</span><span class="n">record_current</span><span class="p">:</span>
                <span class="n">syn</span><span class="o">.</span><span class="n">collect_current</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;must set record_current=True in Synapse class&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synireclist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">synireclist</span>
    
    <span class="k">def</span> <span class="nf">_collect_vsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Collect the membrane voltage of segments with synapses</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">collect_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synvreclist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">synvreclist</span>
    
    <span class="k">def</span> <span class="nf">_collect_istim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the pointprocess currents</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointprocesses</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointprocesses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">record_current</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pointprocesses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">collect_current</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;must set record_current=True for pointp.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stimireclist</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">stimireclist</span>
        
    <span class="k">def</span> <span class="nf">_collect_rec_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rec_variables</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create dict of np.arrays from recorded variables, each dictionary</span>
<span class="sd">        element named as the corresponding recorded variable name, i.e &#39;cai&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rec_variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recvariablesreclist</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rec_variables</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">rec_variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)})</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;collected recorded variable </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">rec_variables</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> 
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">recvariablesreclist</span>
    
    <span class="k">def</span> <span class="nf">_loadspikes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize spiketimes from netcon if they exist</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;synlist&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synlist</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sptimeslist</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synlist</span><span class="o">.</span><span class="n">count</span><span class="p">())):</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sptimeslist</span><span class="o">.</span><span class="n">o</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">netconlist</span><span class="o">.</span><span class="n">o</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sptimeslist</span><span class="o">.</span><span class="n">o</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="n">ii</span><span class="p">]))</span>
            <span class="c1"># elif len(self.synlist) &gt; 0 and len(self.sptimeslist) == 0:</span>
            <span class="c1">#     errmsg = &#39;please run method &quot;set_spike_times() for every&#39; + \</span>
            <span class="c1">#             &#39;\n&#39; + &#39;instance of LFPy.pointprocess.Synapse&#39;</span>
            <span class="c1">#     raise Exception(errmsg)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     pass</span>
            

    
    <span class="k">def</span> <span class="nf">_set_soma_volt_recorder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Record somatic membrane potential</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">somav</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span> 
                                         <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsomasec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsomasec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">somalist</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">somav</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">sec</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">_ref_v</span><span class="p">,</span> 
                              <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsomasec</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="s1">&#39;soma&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">nseg</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">somalist</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nseg</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1">#if 2 segments, record from the first one: </span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">somav</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">:</span>
                            <span class="c1">#record from one of the middle segments:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">somav</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_v</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">def</span> <span class="nf">_set_imem_recorders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Record membrane currents for all segments</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memireclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="n">memirec</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span> 
                                              <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">memirec</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_i_membrane</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">memireclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">memirec</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_set_ipas_recorders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Record passive membrane currents for all segments</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memipasreclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="n">memipasrec</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">memipasrec</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_i_pas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">memipasreclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">memipasrec</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_set_icap_recorders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Record capacitive membrane currents for all segments</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memicapreclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="n">memicaprec</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span> 
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">memicaprec</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_i_cap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">memicapreclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">memicaprec</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_set_voltage_recorders</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Record membrane potentials for all segments</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memvreclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="n">memvrec</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span> 
                                              <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">memvrec</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">memvreclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">memvrec</span><span class="p">)</span>

    
    <span class="k">def</span> <span class="nf">_set_variable_recorders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rec_variables</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a recorder for each variable name in list</span>
<span class="sd">        rec_variables</span>
<span class="sd">        </span>
<span class="sd">        Variables is stored in nested list self.recvariablesreclist</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recvariablesreclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>        
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">rec_variables</span><span class="p">:</span>
            <span class="n">variablereclist</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recvariablesreclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variablereclist</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                    <span class="n">recvector</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tstopms</span> <span class="o">/</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
                        <span class="n">recvector</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="s1">&#39;_ref_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">variable</span><span class="p">),</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">timeres_python</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">((</span><span class="s1">&#39;non-existing variable </span><span class="si">%s</span><span class="s1">, section </span><span class="si">%s</span><span class="s1">.</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> \
                                <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">seg</span><span class="o">.</span><span class="n">x</span><span class="p">)))</span>
                    <span class="n">variablereclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recvector</span><span class="p">)</span>
        
    
<div class="viewcode-block" id="Cell.set_pos"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.set_pos">[docs]</a>    <span class="k">def</span> <span class="nf">set_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xpos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ypos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">zpos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Move the cell geometry so that midpoint of soma section is</span>
<span class="sd">        in (xpos, ypos, zpos). If no soma pos, use the first segment</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">diffx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xpos</span>
        <span class="n">diffy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ypos</span>
        <span class="n">diffz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">zpos</span>
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xpos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ypos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">zpos</span>

        <span class="c1">#also update the pt3d_pos:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt3d</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;x3d&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_pt3d_pos</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span> <span class="o">-=</span> <span class="n">diffx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span> <span class="o">-=</span> <span class="n">diffy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zstart</span> <span class="o">-=</span> <span class="n">diffz</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">xend</span> <span class="o">-=</span> <span class="n">diffx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yend</span> <span class="o">-=</span> <span class="n">diffy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zend</span> <span class="o">-=</span> <span class="n">diffz</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_midpoints</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_synapse_positions</span><span class="p">()</span></div>
        

    
<div class="viewcode-block" id="Cell.strip_hoc_objects"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.strip_hoc_objects">[docs]</a>    <span class="k">def</span> <span class="nf">strip_hoc_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Destroy any NEURON hoc objects in the cell object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">varname</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">))</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">List</span><span class="p">()):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">((</span><span class="s1">&#39;None-typed </span><span class="si">%s</span><span class="s1"> in cell instance&#39;</span> <span class="o">%</span> <span class="n">varname</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="Cell.cellpickler"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.cellpickler">[docs]</a>    <span class="k">def</span> <span class="nf">cellpickler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Save data in cell to filename, using cPickle. It will however destroy</span>
<span class="sd">        any neuron.h objects upon saving, as c-objects cannot be pickled</span>
<span class="sd">        </span>
<span class="sd">        Usage:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            cell.cellpickler(&#39;cell.cpickle&#39;)</span>
<span class="sd">        </span>
<span class="sd">        To load this cell again in another session:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            import cPickle</span>
<span class="sd">            f = file(&#39;cell.cpickle&#39;, &#39;rb&#39;)</span>
<span class="sd">            cell = cPickle.load(f)</span>
<span class="sd">            f.close()</span>
<span class="sd">        </span>
<span class="sd">        alternatively:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            import LFPy</span>
<span class="sd">            cell = LFPy.tools.load(&#39;cell.cpickle&#39;)</span>
<span class="sd">            </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strip_hoc_objects</span><span class="p">()</span>
        <span class="n">filen</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filen</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">filen</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
    
    <span class="k">def</span> <span class="nf">_update_synapse_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Update synapse positions after rotation of morphology</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
<div class="viewcode-block" id="Cell.set_rotation"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.set_rotation">[docs]</a>    <span class="k">def</span> <span class="nf">set_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Rotate geometry of cell object around the x-, y-, z-axis in that order.</span>
<span class="sd">        Input should be angles in radians.</span>
<span class="sd">        </span>
<span class="sd">        using rotation matrices, takes dict with rot. angles,</span>
<span class="sd">        where x, y, z are the rotation angles around respective axes.</span>
<span class="sd">        All rotation angles are optional.</span>
<span class="sd">        </span>
<span class="sd">        Usage:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            cell = LFPy.Cell(**kwargs)</span>
<span class="sd">            rotation = {&#39;x&#39; : 1.233, &#39;y&#39; : 0.236, &#39;z&#39; : np.pi}</span>
<span class="sd">            cell.set_rotation(**rotation)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
            <span class="n">rotation_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]])</span>
            
            <span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_positions</span><span class="p">()</span>
            
            <span class="n">rel_start</span> <span class="o">=</span> <span class="n">rel_start</span> <span class="o">*</span> <span class="n">rotation_x</span>
            <span class="n">rel_end</span> <span class="o">=</span> <span class="n">rel_end</span> <span class="o">*</span> <span class="n">rotation_x</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_real_positions</span><span class="p">(</span><span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;Rotated geometry </span><span class="si">%g</span><span class="s1"> radians around x-axis&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Geometry not rotated around x-axis&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span>
            <span class="n">rotation_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)]])</span>
            
            <span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_positions</span><span class="p">()</span>
            
            <span class="n">rel_start</span> <span class="o">=</span> <span class="n">rel_start</span> <span class="o">*</span> <span class="n">rotation_y</span>
            <span class="n">rel_end</span> <span class="o">=</span> <span class="n">rel_end</span> <span class="o">*</span> <span class="n">rotation_y</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_real_positions</span><span class="p">(</span><span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;Rotated geometry </span><span class="si">%g</span><span class="s1"> radians around y-axis&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">phi</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Geometry not rotated around y-axis&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span>
            <span class="n">rotation_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            
            <span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_positions</span><span class="p">()</span>
            
            <span class="n">rel_start</span> <span class="o">=</span> <span class="n">rel_start</span> <span class="o">*</span> <span class="n">rotation_z</span>
            <span class="n">rel_end</span> <span class="o">=</span> <span class="n">rel_end</span> <span class="o">*</span> <span class="n">rotation_z</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_real_positions</span><span class="p">(</span><span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;Rotated geometry </span><span class="si">%g</span><span class="s1"> radians around z-axis&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">gamma</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Geometry not rotated around z-axis&#39;</span><span class="p">)</span>

        <span class="c1">#rotate the pt3d geometry accordingly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt3d</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;x3d&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_pt3d_rotation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Cell.chiral_morphology"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.chiral_morphology">[docs]</a>    <span class="k">def</span> <span class="nf">chiral_morphology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Mirror the morphology around given axis, (default x-axis),</span>
<span class="sd">        useful to introduce more heterogeneouties in morphology shapes</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            axis : str</span>
<span class="sd">                &#39;x&#39; or &#39;y&#39; or &#39;z&#39;</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#morphology relative to soma-position</span>
        <span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_positions</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;axis must be either &#39;x&#39;, &#39;y&#39; or &#39;z&#39;&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">((</span><span class="s1">&#39;morphology mirrored across </span><span class="si">%s</span><span class="s1">-axis&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">))</span>
        
        <span class="c1">#set the proper 3D positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_real_positions</span><span class="p">(</span><span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span><span class="p">)</span></div>
        
    <span class="k">def</span> <span class="nf">_squeeze_me_macaroni</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reducing the dimensions of the morphology matrices from 3D-&gt;1D</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xend</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yend</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">zstart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zstart</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zend</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
    
    <span class="k">def</span> <span class="nf">_rel_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Morphology relative to soma position</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rel_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xstart</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">zstart</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>    
        <span class="n">rel_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">xend</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">yend</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">zend</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span>

    
    <span class="k">def</span> <span class="nf">_real_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel_start</span><span class="p">,</span> <span class="n">rel_end</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Morphology coordinates relative to Origo</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xstart</span> <span class="o">=</span> <span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ystart</span> <span class="o">=</span> <span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zstart</span> <span class="o">=</span> <span class="n">rel_start</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">xend</span> <span class="o">=</span> <span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yend</span> <span class="o">=</span> <span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zend</span> <span class="o">=</span> <span class="n">rel_end</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_squeeze_me_macaroni</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_midpoints</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_synapse_positions</span><span class="p">()</span>

    
<div class="viewcode-block" id="Cell.get_rand_prob_area_norm"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_rand_prob_area_norm">[docs]</a>    <span class="k">def</span> <span class="nf">get_rand_prob_area_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s1">&#39;allsec&#39;</span><span class="p">,</span> 
                                <span class="n">z_min</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span> <span class="n">z_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the probability (0-1) for synaptic coupling on segments</span>
<span class="sd">        in section sum(prob)=1 over all segments in section.</span>
<span class="sd">        Prob. determined by area.</span>

<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">           </span>
<span class="sd">            section: str, string matching a section-name</span>
<span class="sd">            z_min: float, depth filter</span>
<span class="sd">            z_max: float depth filter            </span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">,</span> <span class="n">z_min</span><span class="o">=</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span> <span class="o">=</span> <span class="n">z_max</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">prob</span></div>

<div class="viewcode-block" id="Cell.get_rand_prob_area_norm_from_idx"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_rand_prob_area_norm_from_idx">[docs]</a>    <span class="k">def</span> <span class="nf">get_rand_prob_area_norm_from_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> 
                                <span class="n">z_min</span><span class="o">=-</span><span class="mi">10000</span><span class="p">,</span> <span class="n">z_max</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the normalized probability (0-1) for synaptic coupling on</span>
<span class="sd">        segments in idx-array.</span>
<span class="sd">        Normalised probability determined by area of segments.</span>

<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            idx : np.ndarray, dtype=int.</span>
<span class="sd">                array of segment indices</span>
<span class="sd">            z_min: float, depth filter</span>
<span class="sd">            z_max: float depth filter            </span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">prob</span></div>
    
<div class="viewcode-block" id="Cell.get_intersegment_vector"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_intersegment_vector">[docs]</a>    <span class="k">def</span> <span class="nf">get_intersegment_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx1</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the distance between midpoints of two segments with index</span>
<span class="sd">        idx0 and idx1. The argument returned is a vector [x, y, z], where</span>
<span class="sd">        x = self.xmid[idx1] - self.xmid[idx0] etc.</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            idx0 : int</span>
<span class="sd">            idx1 : int</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">idx0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span>
            <span class="n">vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xmid</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmid</span><span class="p">[</span><span class="n">idx0</span><span class="p">])</span>
            <span class="n">vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ymid</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ymid</span><span class="p">[</span><span class="n">idx0</span><span class="p">])</span>
            <span class="n">vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmid</span><span class="p">[</span><span class="n">idx0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">vector</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">ERRMSG</span> <span class="o">=</span> <span class="s1">&#39;idx0 and idx1 must be ints on [0, </span><span class="si">%i</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ERRMSG</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Cell.get_intersegment_distance"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_intersegment_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_intersegment_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx1</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the Euclidean distance between midpoints of two segments </span>
<span class="sd">        with indices idx0 and idx1. Will return a float in unit of micrometers.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_intersegment_vector</span><span class="p">(</span><span class="n">idx0</span><span class="p">,</span> <span class="n">idx1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vector</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">ERRMSG</span> <span class="o">=</span> <span class="s1">&#39;idx0 and idx1 must be ints on [0, </span><span class="si">%i</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ERRMSG</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="Cell.get_idx_children"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_idx_children">[docs]</a>    <span class="k">def</span> <span class="nf">get_idx_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="s2">&quot;soma[0]&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the idx of parent&#39;s children sections, i.e. compartments ids</span>
<span class="sd">        of sections connected to parent-argument</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            parent: str</span>
<span class="sd">                name-pattern matching a sectionname</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idxvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">)</span>
        <span class="n">secnamelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">childseclist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#filling list of sectionnames for all sections, one entry per segment</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="n">secnamelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="c1">#filling list of children section-names</span>
        <span class="n">sref</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">SectionRef</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">sref</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>
            <span class="n">childseclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="c1">#idxvec=1 where both coincide</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">secnamelist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">childsec</span> <span class="ow">in</span> <span class="n">childseclist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sec</span> <span class="o">==</span> <span class="n">childsec</span><span class="p">:</span>
                    <span class="n">idxvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idxvec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span></div>

<div class="viewcode-block" id="Cell.get_idx_parent_children"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_idx_parent_children">[docs]</a>    <span class="k">def</span> <span class="nf">get_idx_parent_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="s2">&quot;soma[0]&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get all idx of segments of parent and children sections, i.e. segment</span>
<span class="sd">        idx of sections connected to parent-argument, and also of the parent</span>
<span class="sd">        segments</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            parent: str</span>
<span class="sd">                name-pattern matching a sectionname</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idxvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">)</span>
        <span class="n">secnamelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">childseclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent</span><span class="p">]</span>
        <span class="c1">#filling list of sectionnames for all sections, one entry per segment</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="n">secnamelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="c1">#filling list of children section-names</span>
        <span class="n">sref</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">SectionRef</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">sref</span><span class="o">.</span><span class="n">child</span><span class="p">:</span>
            <span class="n">childseclist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="c1">#idxvec=1 where both coincide</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">secnamelist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">childsec</span> <span class="ow">in</span> <span class="n">childseclist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sec</span> <span class="o">==</span> <span class="n">childsec</span><span class="p">:</span>
                    <span class="n">idxvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idxvec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_idx</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span> <span class="n">idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="Cell.get_idx_name"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_idx_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_idx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return NEURON convention name of segments with index idx.</span>
<span class="sd">        The returned argument is a list of tuples with corresponding</span>
<span class="sd">        segment idx, section name, and position along the section, like;</span>
<span class="sd">        [(0, &#39;neuron.h.soma[0]&#39;, 0.5),]</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            idx : np.ndarray, dtype int</span>
<span class="sd">                segment indices, must be between 0 and cell.totnsegs        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#ensure idx is array-like, or convert</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1">#ensure all idx are valid</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">):</span>
            <span class="n">wrongidx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">)]</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;idx </span><span class="si">%s</span><span class="s1"> &gt;= number of compartments&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">wrongidx</span><span class="p">))</span>
        
        <span class="c1">#create list of seg names:</span>
        <span class="n">allsegnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">segidx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="n">allsegnames</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">segidx</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span>  <span class="o">%</span> <span class="n">sec</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">seg</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
                <span class="n">segidx</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">allsegnames</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_collect_pt3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;collect the pt3d info, for each section&#39;&#39;&#39;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="n">n3d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">n3d</span><span class="p">())</span>
            <span class="n">x_i</span><span class="p">,</span> <span class="n">y_i</span><span class="p">,</span> <span class="n">z_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n3d</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n3d</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n3d</span><span class="p">),</span>
            <span class="n">d_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n3d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n3d</span><span class="p">):</span>
                <span class="n">x_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">x3d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">y_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">y3d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">z_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">z3d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">d_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">diam3d</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_i</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span>
            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_i</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_i</span><span class="p">)</span>
        
        <span class="c1">#remove offsets which may be present if soma is centred in Origo</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xoff</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">yoff</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">zoff</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">xoff</span>
                <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">yoff</span>
                <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">zoff</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">d</span>

            
    <span class="k">def</span> <span class="nf">_update_pt3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>           
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        update the locations in neuron.hoc.space using neuron.h.pt3dchange()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="n">n3d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">n3d</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n3d</span><span class="p">):</span>
                <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">pt3dchange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">diam3d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#let NEURON know about the changes we just did:</span>
            <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">define_shape</span><span class="p">()</span>
        <span class="c1">#must recollect the geometry, otherwise we get roundoff errors!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_geometry</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_set_pt3d_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Offset pt3d geometry with cell.somapos</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_pt3d</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_set_pt3d_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Rotate pt3d geometry of cell object around the x-, y-, z-axis</span>
<span class="sd">        in that order.</span>
<span class="sd">        Input should be angles in radians.</span>
<span class="sd">        </span>
<span class="sd">        using rotation matrices, takes dict with rot. angles,</span>
<span class="sd">        where x, y, z are the rotation angles around respective axes.</span>
<span class="sd">        All rotation angles are optional.</span>
<span class="sd">        </span>
<span class="sd">        Usage:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            cell = LFPy.Cell(**kwargs)</span>
<span class="sd">            rotation = {&#39;x&#39; : 1.233, &#39;y&#39; : 0.236, &#39;z&#39; : np.pi}</span>
<span class="sd">            cell.set_pt3d_rotation(**rotation)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
            <span class="n">rotation_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">)):</span>
                <span class="n">rel_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_pt3d_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                
                <span class="n">rel_pos</span> <span class="o">=</span> <span class="n">rel_pos</span> <span class="o">*</span> <span class="n">rotation_x</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_real_pt3d_positions</span><span class="p">(</span><span class="n">rel_pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;Rotated geometry </span><span class="si">%g</span><span class="s1"> radians around x-axis&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">theta</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Geometry not rotated around x-axis&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span>
            <span class="n">rotation_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)]])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">)):</span>
                <span class="n">rel_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_pt3d_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                
                <span class="n">rel_pos</span> <span class="o">=</span> <span class="n">rel_pos</span> <span class="o">*</span> <span class="n">rotation_y</span>
                                
                <span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_real_pt3d_positions</span><span class="p">(</span><span class="n">rel_pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;Rotated geometry </span><span class="si">%g</span><span class="s1"> radians around y-axis&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">phi</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Geometry not rotated around y-axis&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span>
            <span class="n">rotation_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">)):</span>
                <span class="n">rel_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_pt3d_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                
                <span class="n">rel_pos</span> <span class="o">=</span> <span class="n">rel_pos</span> <span class="o">*</span> <span class="n">rotation_z</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y3d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">z3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_real_pt3d_positions</span><span class="p">(</span><span class="n">rel_pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">((</span><span class="s1">&#39;Rotated geometry </span><span class="si">%g</span><span class="s1"> radians around z-axis&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">gamma</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Geometry not rotated around z-axis&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_pt3d</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_rel_pt3d_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Morphology relative to soma position</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">rel_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                         <span class="n">z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>

        <span class="k">return</span> <span class="n">rel_pos</span>
    
    <span class="k">def</span> <span class="nf">_real_pt3d_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel_pos</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Morphology coordinates relative to Origo</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">rel_pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rel_pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">rel_pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">somapos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
    
    <span class="k">def</span> <span class="nf">_create_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;create a polygon to fill for each section&#39;&#39;&#39;</span>        
        <span class="n">x</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;3d&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;3d&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1">#x = self.x3d[i]</span>
        <span class="c1">#z = self.z3d[i]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1">#calculate angles        </span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">theta</span><span class="p">,</span> <span class="n">theta</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        
        <span class="c1">#1st corner:</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1">##pt3d points between start and end of section, first side</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]))</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]))</span>
        
        <span class="c1">#end of section, first side</span>
        <span class="n">x</span><span class="p">[</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        <span class="n">y</span><span class="p">[</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        
        <span class="c1">#other side</span>
        <span class="c1">#end of section, second side</span>
        <span class="n">x</span><span class="p">[</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        <span class="n">y</span><span class="p">[</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        
        <span class="c1">##pt3d points between start and end of section, second side</span>
        <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">d</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]))</span>
        <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">d</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">dy</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="n">dx</span><span class="o">.</span><span class="n">size</span><span class="p">]))</span>

        <span class="c1">#last corner:</span>
        <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
    
<div class="viewcode-block" id="Cell.get_pt3d_polygons"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_pt3d_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">get_pt3d_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;for each section create a polygon in the plane determined by keyword</span>
<span class="sd">        argument projection=(&#39;x&#39;, &#39;z&#39;), that can be</span>
<span class="sd">        visualized using e.g., plt.fill()</span>
<span class="sd">        </span>
<span class="sd">        Returned argument is a list of (x, z) tuples giving the trajectory</span>
<span class="sd">        of each section that can be plotted using PolyCollection</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            from matplotlib.collections import PolyCollection</span>
<span class="sd">            import matplotlib.pyplot as plt</span>
<span class="sd">            </span>
<span class="sd">            cell = LFPy.Cell(morphology=&#39;PATH/TO/MORPHOLOGY&#39;)</span>
<span class="sd">            </span>
<span class="sd">            zips = []</span>
<span class="sd">            for x, z in cell.get_idx_polygons(projection=(&#39;x&#39;, &#39;z&#39;)):</span>
<span class="sd">                zips.append(zip(x, z))</span>
<span class="sd">            </span>
<span class="sd">            polycol = PolyCollection(zips,</span>
<span class="sd">                                     edgecolors=&#39;none&#39;,</span>
<span class="sd">                                     facecolors=&#39;gray&#39;)</span>
<span class="sd">            </span>
<span class="sd">            fig = plt.figure()</span>
<span class="sd">            ax = fig.add_subplot(111)</span>
<span class="sd">            </span>
<span class="sd">            ax.add_collection(polycol)</span>
<span class="sd">            ax.axis(ax.axis(&#39;equal&#39;))</span>
<span class="sd">            </span>
<span class="sd">            plt.show()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;projection arg be a tuple like (&#39;x&#39;, &#39;y&#39;)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">projection</span> <span class="ow">and</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">projection</span> <span class="ow">and</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">projection</span> <span class="ow">and</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mssg</span> <span class="o">=</span> <span class="s2">&quot;projection must be a length 2 tuple of &#39;x&#39;, &#39;y&#39; or &#39;z&#39;!&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">messg</span><span class="p">)</span>

        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3d</span><span class="p">)):</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_polygon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">projection</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">polygons</span></div>


    <span class="k">def</span> <span class="nf">_create_segment_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;create a polygon to fill for segment i, in the plane</span>
<span class="sd">        determined by kwarg projection&#39;&#39;&#39;</span>        
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;start&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span>
             <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;end&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;start&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span>
             <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;end&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]]</span>        
        <span class="c1">#x = [self.xstart[i], self.xend[i]]</span>
        <span class="c1">#z = [self.zstart[i], self.zend[i]]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diam</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1">#calculate angles        </span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                
        <span class="c1">#1st corner:</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                
        <span class="c1">#end of section, first side</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="c1">#other side</span>
        <span class="c1">#end of section, second side</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="c1">#last corner:</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span>


<div class="viewcode-block" id="Cell.get_idx_polygons"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.get_idx_polygons">[docs]</a>    <span class="k">def</span> <span class="nf">get_idx_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;for each segment idx in celll create a polygon in the plane</span>
<span class="sd">        determined by the projection kwarg (default (&#39;x&#39;, &#39;z&#39;)),</span>
<span class="sd">        that can be visualized using plt.fill() or</span>
<span class="sd">        mpl.collections.PolyCollection</span>
<span class="sd">        </span>
<span class="sd">        Returned argument is a list of (np.ndarray, np.ndarray) tuples</span>
<span class="sd">        giving the trajectory of each section</span>
<span class="sd">        </span>
<span class="sd">        kwargs:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            projection : (&#39;x&#39;, &#39;z&#39;) tuple of two strings determining projection </span>
<span class="sd">        </span>
<span class="sd">        The most efficient way of using this would be something like</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            from matplotlib.collections import PolyCollection</span>
<span class="sd">            import matplotlib.pyplot as plt</span>
<span class="sd">            </span>
<span class="sd">            cell = LFPy.Cell(morphology=&#39;PATH/TO/MORPHOLOGY&#39;)</span>
<span class="sd">            </span>
<span class="sd">            zips = []</span>
<span class="sd">            for x, z in cell.get_idx_polygons(projection=(&#39;x&#39;, &#39;z&#39;)):</span>
<span class="sd">                zips.append(zip(x, z))</span>
<span class="sd">            </span>
<span class="sd">            polycol = PolyCollection(zips,</span>
<span class="sd">                                     edgecolors=&#39;none&#39;,</span>
<span class="sd">                                     facecolors=&#39;gray&#39;)</span>
<span class="sd">            </span>
<span class="sd">            fig = plt.figure()</span>
<span class="sd">            ax = fig.add_subplot(111)</span>
<span class="sd">            </span>
<span class="sd">            ax.add_collection(polycol)</span>
<span class="sd">            ax.axis(ax.axis(&#39;equal&#39;))</span>
<span class="sd">            </span>
<span class="sd">            plt.show()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;projection arg be a tuple like (&#39;x&#39;, &#39;y&#39;)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">projection</span> <span class="ow">and</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">projection</span> <span class="ow">and</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">projection</span> <span class="ow">and</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">projection</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mssg</span> <span class="o">=</span> <span class="s2">&quot;projection must be a length 2 tuple of &#39;x&#39;, &#39;y&#39; or &#39;z&#39;!&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">messg</span><span class="p">)</span>

        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">):</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_segment_polygon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">projection</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">polygons</span></div>



<div class="viewcode-block" id="Cell.insert_v_ext"><a class="viewcode-back" href="../../classes.html#LFPy.Cell.insert_v_ext">[docs]</a>    <span class="k">def</span> <span class="nf">insert_v_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_ext</span><span class="p">,</span> <span class="n">t_ext</span><span class="p">):</span>        
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        playback of some extracellular potential v_ext on each cell.totnseg</span>
<span class="sd">        compartments. Assumes that the &quot;extracellular&quot;-mechanism is inserted</span>
<span class="sd">        on each compartment.</span>
<span class="sd">        </span>
<span class="sd">        Can be used to study ephaptic effects and similar</span>
<span class="sd">        </span>
<span class="sd">        The inputs will be copied and attached to the cell object as</span>
<span class="sd">        cell.v_ext, cell.t_ext, and converted</span>
<span class="sd">        to (list of) neuron.h.Vector types, to allow playback into each</span>
<span class="sd">        compartment e_extracellular reference.</span>
<span class="sd">        </span>
<span class="sd">        Can not be deleted prior to running cell.simulate() </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            v_ext : cell.totnsegs x t_ext.size np.array, unit mV</span>
<span class="sd">            t_ext : np.array, time vector of v_ext</span>
<span class="sd">        </span>
<span class="sd">        Simple usage:</span>
<span class="sd">        ::</span>
<span class="sd">            </span>
<span class="sd">            import LFPy</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import matplotlib.pyplot as plt</span>
<span class="sd">            </span>
<span class="sd">            #create cell</span>
<span class="sd">            cell = LFPy.Cell(morphology=&#39;morphologies/example_morphology.hoc&#39;)</span>
<span class="sd">            </span>
<span class="sd">            #time vector and extracellular field for every segment:</span>
<span class="sd">            t_ext = np.arange(cell.tstopms / cell.timeres_python+ 1) * \</span>
<span class="sd">                    cell.timeres_python</span>
<span class="sd">            v_ext = np.random.rand(cell.totnsegs, t_ext.size)-0.5</span>
<span class="sd">        </span>
<span class="sd">            #insert potentials and record response:</span>
<span class="sd">            cell.insert_v_ext(v_ext, t_ext)</span>
<span class="sd">            cell.simulate(rec_imem=True, rec_vmem=True)</span>
<span class="sd">        </span>
<span class="sd">            fig = plt.figure()</span>
<span class="sd">            ax1 = fig.add_subplot(311)</span>
<span class="sd">            ax2 = fig.add_subplot(312)</span>
<span class="sd">            ax3 = fig.add_subplot(313)</span>
<span class="sd">            eim = ax1.matshow(np.array(cell.v_ext), cmap=&#39;spectral&#39;)</span>
<span class="sd">            cb1 = fig.colorbar(eim, ax=ax1)</span>
<span class="sd">            cb1.set_label(&#39;v_ext&#39;)</span>
<span class="sd">            ax1.axis(ax1.axis(&#39;tight&#39;))</span>
<span class="sd">            iim = ax2.matshow(cell.imem, cmap=&#39;spectral&#39;)</span>
<span class="sd">            cb2 = fig.colorbar(iim, ax=ax2)</span>
<span class="sd">            cb2.set_label(&#39;imem&#39;)</span>
<span class="sd">            ax2.axis(ax2.axis(&#39;tight&#39;))</span>
<span class="sd">            vim = ax3.matshow(cell.vmem, cmap=&#39;spectral&#39;)</span>
<span class="sd">            ax3.axis(ax3.axis(&#39;tight&#39;))</span>
<span class="sd">            cb3 = fig.colorbar(vim, ax=ax3)</span>
<span class="sd">            cb3.set_label(&#39;vmem&#39;)</span>
<span class="sd">            ax3.set_xlabel(&#39;tstep&#39;)</span>
<span class="sd">            plt.show()</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#test dimensions of input</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v_ext</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">totnsegs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;v_ext.shape[0] != cell.totnsegs&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v_ext</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">t_ext</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;v_ext.shape[1] != t_ext.size&#39;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;v_ext, t_ext must both be np.array types&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">extracellular</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;LFPy.Cell arg extracellular != True&#39;</span><span class="p">)</span>
        
        <span class="c1">#create list of extracellular potentials on each segment, time vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_ext</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="n">t_ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_ext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">v_ext</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_ext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">h</span><span class="o">.</span><span class="n">Vector</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="c1">#play v_ext into e_extracellular reference</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allseclist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">v_ext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">play</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">_ref_e_extracellular</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_ext</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">LFPy 1.1.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Computational Neuroscience Group, NMBU.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
<!--<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.-->
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>